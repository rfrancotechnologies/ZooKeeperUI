/**
 * ZooKeeper REST API
 * The ZooKeeper REST API provides support for the ZooKeeperUI web application. The API provides different endpoints to access and modify ZooKeeper ZNodes.  ### Authentication  All the operations of this API are authenticated. In order to start a new player session you need to invoke the `POST /sessions` operation, providing some user credentials. This operation will include an `ACCESS_TOKEN` cookie in the returned response, containing an authentication token.  This cookie must be provided in any subsequent call to the API in order to be correctly authenticated. If you are accessing this API from a web application running in a browser, the browser will already do it for you.  The returned `ACCESS_TOKEN` cookie will expire after a configurable amount of time. In order to keep your session open you have to refresh your session via the `PUT /sessions/current` operation.  A default authentication provider is included, that checks the user credentials against the `users` configuration property, which is an array of user name and password tuples. As this is a Spring Boot application, the `users` configuration property can be provided via a configuration file, environment variables, command line arguments, and Java properties.   In addition to the default authentication provider, you can provide your own, by implementing the **TODO** interface and adding your implementation to the classpath when running the application.  In order to allow users to access the API, not only have them to be authenticated, but they also need to provide the appropriate user claims. User claims grant the user permissions to perform some certain actions. Currently the only requested claim for the whole application is `ZOOKEEPER_USER`.   If you are using the default user authentication provider (based on the configuration properties), all the authenticated users will have this permission included by default. If you are using your custom authentication provider, you will have to make sure that the users have the `ZOOKEEPER_USER` claim. 
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';
import 'rxjs/add/operator/map';

import * as models                                           from '../model/models';
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class ConfigApi {

    protected basePath = 'http://localhost';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
        }
    }

    /**
     * Creates a new child of the given data node.
     * Creates a new child of the given data node.
     * @param nodePath The path of the node that will be added a child (using ~~ instead of / as zpath separator).
     * @param body The data of the new node (name and value).
     */
    public addNodeChild(nodePath: string, body?: models.NodeCreationRequest, extraHttpRequestParams?: any): Observable<{}> {
        return this.addNodeChildWithHttpInfo(nodePath, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Deletes the given data node.
     * Deletes the given data node.
     * @param nodePath The path of the node whose data will be deleted (using ~~ instead of / as zpath separator).
     */
    public deleteNode(nodePath: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteNodeWithHttpInfo(nodePath, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves the children of the given data node.
     * Retrieves the children of the given data node.
     * @param nodePath The path of the node whose children will be retrieved (using ~~ instead of / as zpath separator).
     */
    public getNodeChildren(nodePath: string, extraHttpRequestParams?: any): Observable<models.ChildrenNodes> {
        return this.getNodeChildrenWithHttpInfo(nodePath, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves the data of the given data node.
     * Retrieves the data of the given data node.
     * @param nodePath The path of the node whose data will be retrieved (using ~~ instead of / as zpath separator).
     */
    public getNodeData(nodePath: string, extraHttpRequestParams?: any): Observable<models.NodeData> {
        return this.getNodeDataWithHttpInfo(nodePath, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves the data type of the given node.
     * Retrieves the data type of the given node.
     * @param nodePath The path of the node whose data type will be retrieved (using ~~ instead of / as zpath separator).
     */
    public getNodeDataType(nodePath: string, extraHttpRequestParams?: any): Observable<models.NodeDataType> {
        return this.getNodeDataTypeWithHttpInfo(nodePath, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Retrieves an export for the given node.
     * Retrieves an export for the given node. The export contains the node, including its path and value, and all of its children. Exports are useful for saving snapshots of a given node and subsequently restoring them.
     * @param nodePath The path of the node whose data will be exported (using ~~ instead of / as zpath separator).
     */
    public getNodeExport(nodePath: string, extraHttpRequestParams?: any): Observable<models.NodeExport> {
        return this.getNodeExportWithHttpInfo(nodePath, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Imports a previously obtained export into the given node.
     * Imports a previously obtained export into the given node. It is possible to specify whether the value of already existing nodes should be overwritten, and whether the import should prune nodes existing in ZooKeeper that do not exist in the export.
     * @param nodePath The path of the node whose data will be restored (using ~~ instead of / as zpath separator).
     * @param prune Indicates whether the import should prune nodes existing in ZooKeeper that do not exist in the export. The default is &#x60;false&#x60;.
     * @param overwrite Indicates whether the value of already existing nodes should be overwritten. The default is &#x60;true&#x60;.
     * @param node The node export that will be restored into the specified path.
     */
    public restoreNodeExport(nodePath: string, prune?: boolean, overwrite?: boolean, node?: models.NodeExport, extraHttpRequestParams?: any): Observable<{}> {
        return this.restoreNodeExportWithHttpInfo(nodePath, prune, overwrite, node, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Sets the data of the given data node.
     * Sets the data of the given data node.
     * @param nodePath The path of the node whose data will be set (using ~~ instead of / as zpath separator).
     * @param nodeData The data to set to the given node.
     */
    public setNodeData(nodePath: string, nodeData?: models.NodeData, extraHttpRequestParams?: any): Observable<{}> {
        return this.setNodeDataWithHttpInfo(nodePath, nodeData, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }

    /**
     * Sets the data type of the given node.
     * Sets the data type of the given node.
     * @param nodePath The path of the node whose data will be restored (using ~~ instead of / as zpath separator).
     * @param nodeDataType The node data type to set to the node at the specified path.
     */
    public setNodeDataType(nodePath: string, nodeDataType: models.NodeDataType, extraHttpRequestParams?: any): Observable<{}> {
        return this.setNodeDataTypeWithHttpInfo(nodePath, nodeDataType, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return response.json() || {};
                }
            });
    }


    /**
     * Creates a new child of the given data node.
     * Creates a new child of the given data node.
     * @param nodePath The path of the node that will be added a child (using ~~ instead of / as zpath separator).
     * @param body The data of the new node (name and value).
     */
    public addNodeChildWithHttpInfo(nodePath: string, body?: models.NodeCreationRequest, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/nodes/${nodePath}/children'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling addNodeChild.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Deletes the given data node.
     * Deletes the given data node.
     * @param nodePath The path of the node whose data will be deleted (using ~~ instead of / as zpath separator).
     */
    public deleteNodeWithHttpInfo(nodePath: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/nodes/${nodePath}'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling deleteNode.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieves the children of the given data node.
     * Retrieves the children of the given data node.
     * @param nodePath The path of the node whose children will be retrieved (using ~~ instead of / as zpath separator).
     */
    public getNodeChildrenWithHttpInfo(nodePath: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/nodes/${nodePath}/children'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling getNodeChildren.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieves the data of the given data node.
     * Retrieves the data of the given data node.
     * @param nodePath The path of the node whose data will be retrieved (using ~~ instead of / as zpath separator).
     */
    public getNodeDataWithHttpInfo(nodePath: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/nodes/${nodePath}'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling getNodeData.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieves the data type of the given node.
     * Retrieves the data type of the given node.
     * @param nodePath The path of the node whose data type will be retrieved (using ~~ instead of / as zpath separator).
     */
    public getNodeDataTypeWithHttpInfo(nodePath: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/nodes/${nodePath}/data_type'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling getNodeDataType.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Retrieves an export for the given node.
     * Retrieves an export for the given node. The export contains the node, including its path and value, and all of its children. Exports are useful for saving snapshots of a given node and subsequently restoring them.
     * @param nodePath The path of the node whose data will be exported (using ~~ instead of / as zpath separator).
     */
    public getNodeExportWithHttpInfo(nodePath: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/nodes/${nodePath}/export'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling getNodeExport.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Imports a previously obtained export into the given node.
     * Imports a previously obtained export into the given node. It is possible to specify whether the value of already existing nodes should be overwritten, and whether the import should prune nodes existing in ZooKeeper that do not exist in the export.
     * @param nodePath The path of the node whose data will be restored (using ~~ instead of / as zpath separator).
     * @param prune Indicates whether the import should prune nodes existing in ZooKeeper that do not exist in the export. The default is &#x60;false&#x60;.
     * @param overwrite Indicates whether the value of already existing nodes should be overwritten. The default is &#x60;true&#x60;.
     * @param node The node export that will be restored into the specified path.
     */
    public restoreNodeExportWithHttpInfo(nodePath: string, prune?: boolean, overwrite?: boolean, node?: models.NodeExport, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/nodes/${nodePath}/export'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling restoreNodeExport.');
        }
        if (prune !== undefined) {
            queryParameters.set('prune', <any>prune);
        }

        if (overwrite !== undefined) {
            queryParameters.set('overwrite', <any>overwrite);
        }

        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: node == null ? '' : JSON.stringify(node), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Sets the data of the given data node.
     * Sets the data of the given data node.
     * @param nodePath The path of the node whose data will be set (using ~~ instead of / as zpath separator).
     * @param nodeData The data to set to the given node.
     */
    public setNodeDataWithHttpInfo(nodePath: string, nodeData?: models.NodeData, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/nodes/${nodePath}'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling setNodeData.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: nodeData == null ? '' : JSON.stringify(nodeData), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Sets the data type of the given node.
     * Sets the data type of the given node.
     * @param nodePath The path of the node whose data will be restored (using ~~ instead of / as zpath separator).
     * @param nodeDataType The node data type to set to the node at the specified path.
     */
    public setNodeDataTypeWithHttpInfo(nodePath: string, nodeDataType: models.NodeDataType, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/api/nodes/${nodePath}/data_type'
                    .replace('${' + 'nodePath' + '}', String(nodePath));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845
        // verify required parameter 'nodePath' is not null or undefined
        if (nodePath === null || nodePath === undefined) {
            throw new Error('Required parameter nodePath was null or undefined when calling setNodeDataType.');
        }
        // verify required parameter 'nodeDataType' is not null or undefined
        if (nodeDataType === null || nodeDataType === undefined) {
            throw new Error('Required parameter nodeDataType was null or undefined when calling setNodeDataType.');
        }
        // to determine the Content-Type header
        let consumes: string[] = [
        ];

        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: nodeDataType == null ? '' : JSON.stringify(nodeDataType), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
